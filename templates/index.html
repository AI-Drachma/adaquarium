<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cardano Aquarium</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: url("/static/aquarium-bg.png") no-repeat center center;
      background-size: cover;
      font-family: sans-serif;
    }
    #title {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 28px;
      font-weight: bold;
      text-shadow: 1px 1px 4px black;
      z-index: 10;
    }
    #boat {
      position: absolute;
      top: 10px;
      left: 20px;
      width: 80px;
      z-index: 10;
    }
    #pause-btn {
      position: absolute;
      top: 25px;
      left: 30px;
      background: white;
      border: none;
      font-weight: bold;
      padding: 2px 8px;
      z-index: 11;
      cursor: pointer;
    }
    #day-night-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: white;
      border: none;
      font-weight: bold;
      padding: 5px 10px;
      cursor: pointer;
      z-index: 10;
    }
    #search-controls {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      z-index: 15;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    #search-controls button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 12px;
      margin: 0 5px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    #search-controls button:hover {
      background: #45a049;
    }
    #block-input {
      padding: 8px;
      margin: 0 5px;
      border: 2px solid #ddd;
      border-radius: 5px;
      width: 100px;
      text-align: center;
      font-size: 14px;
    }
    #aquarium {
      position: absolute;
      top: 80px;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      z-index: 1;
    }
    #radar-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 5px;
      background: red;
      z-index: 50;
      display: block;
      box-shadow: 0 0 15px red;
      left: 0px;
    }
    .block-column {
      position: absolute;
      bottom: 0;
      width: 120px;
      text-align: center;
      font-weight: bold;
      color: red;
      z-index: 3;
    }
    .creature {
      position: absolute;
      height: auto;
      transition: all 0.5s linear;
      cursor: pointer;
      user-select: none;
      z-index: 4;
      transform-origin: center;
      filter: contrast(1.2) brightness(1.1);
      mix-blend-mode: multiply;
    }
    .creature.dragging {
      cursor: grabbing;
      z-index: 100;
    }
    .creature.fade-out {
      opacity: 0;
      transition: opacity 1s ease-out;
    }
    #info-panel {
      position: absolute;
      top: 100px;
      right: 0px;
      width: 350px;
      height: 550px;
      background-image: url("/static/panel.png");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: right center;
      z-index: 10;
    }
    #info-panel-header {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 13px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
      z-index: 11;
    }
    #info-content {
      position: absolute;
      top: 150px;
      left: 70px;
      width: 200px;
      height: 280px;
      color: black;
      font-size: 12px;
      line-height: 1.2;
      word-wrap: break-word;
      overflow-wrap: break-word;
      word-break: break-all;
      text-align: left;
      padding: 0px;
      box-sizing: border-box;
      overflow-y: auto;
      border: none;
      background: transparent;
    }
    @keyframes spookyGlow {
      0% {
        text-shadow: 0 0 10px #ff6b6b, 0 0 20px #ff0000;
        opacity: 0.8;
      }
      100% {
        text-shadow: 0 0 20px #ff6b6b, 0 0 30px #ff0000, 0 0 40px #ff0000;
        opacity: 1;
      }
    }
    @keyframes ripple {
      0% {
        transform: scale(0);
        opacity: 1;
      }
      100% {
        transform: scale(4);
        opacity: 0;
      }
    }
    .ripple-effect {
      position: absolute;
      border: 2px solid rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: ripple 1s ease-out;
      pointer-events: none;
      z-index: 100;
    }
    .transaction-arrow {
      position: absolute;
      height: 2px;
      background: linear-gradient(to right, rgba(255, 255, 0, 0.8), rgba(255, 200, 0, 0.4));
      transform-origin: left center;
      pointer-events: none;
      z-index: 50;
      box-shadow: 0 0 5px rgba(255, 255, 0, 0.3);
    }
    .transaction-arrow::after {
      content: '';
      position: absolute;
      right: 0;
      top: -3px;
      width: 0;
      height: 0;
      border-left: 8px solid rgba(255, 255, 0, 0.8);
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
    }
    #creature-boundary {
      position: absolute;
      border: 4px solid red !important;
      opacity: 0.9 !important;
      pointer-events: none;
      z-index: 15;
      box-sizing: border-box;
      background-color: rgba(255, 0, 0, 0.15) !important;
      display: block !important;
      visibility: visible !important;
      /* Removed min-width/height to show actual space */
    }
    #selected-creature-circle {
      position: absolute;
      border: 3px solid rgba(0, 255, 0, 0.8);
      border-radius: 50%;
      background-color: rgba(0, 255, 0, 0.2);
      pointer-events: none;
      z-index: 20;
      display: none;
      transition: all 0.3s ease;
    }
  </style>
</head>
<body>
  <div id="title">Cardano Aquarium</div>
  <img id="boat" src="/static/boat.png" />
  <button id="pause-btn">‚è∏</button>
  <button id="day-night-toggle">Day</button>
  <div id="info-panel">
    <div id="info-panel-header">Wallet Info</div>
    <div id="info-content"></div>
  </div>
  <div id="search-controls">
    <button id="block-prev">‚óÄ</button>
    <input id="block-input" type="number" value="3744495" min="1">
    <button id="block-next">‚ñ∂</button>
  </div>
  <div id="aquarium">
    <div id="radar-line"></div>
    <div id="creature-boundary" style="position: absolute; left: 20px; top: 120px; width: 400px; height: 400px; border: 5px solid red; background-color: rgba(255,0,0,0.2); display: block; visibility: visible; opacity: 1; z-index: 15; pointer-events: none; box-sizing: border-box;"></div>
    <div id="selected-creature-circle"></div>
    <!-- TEST ELEMENT - This should definitely be visible -->
    <div style="position: absolute; left: 50px; top: 50px; width: 200px; height: 200px; border: 10px solid blue; background-color: yellow; z-index: 999;">TEST BOX - Should be visible</div>
  </div>

  <script>
    const aquarium = document.getElementById("aquarium");
    const creatureImages = {
      shrimp: {
        gif: "/static/shrimp.gif",
        png: "/static/shrimp.png"
      },
      crab: {
        gif: "/static/crab.gif",
        png: "/static/crab.png"
      },
      octopus: {
        gif: "/static/octopus.gif",
        png: "/static/octopus.png"
      },
      fish: {
        gif: "/static/fish.gif",
        png: "/static/fish.png"
      },
      tuna: {
        gif: "/static/tuna.gif",
        png: "/static/tuna.png"
      },
      dolphin: {
        gif: "/static/dolphin.gif",
        png: "/static/dolphin.png"
      },
      shark: {
        gif: "/static/shark.gif", 
        png: "/static/shark.png"
      },
      whale: {
        gif: "/static/whale.gif",
        png: "/static/whale.png"
      }
    };

    let paused = false;
    let isNightMode = false;
    let radarPosition = 0;
    let currentCreatures = [];
    let draggedCreature = null;
    let dragOffset = { x: 0, y: 0 };
    let searchBlockHeight = 0; // Will be set to latest block
    let activeArrows = []; // Track active arrows for position updates
    let selectedCreature = null; // Track creature currently shown in info panel

    function startCreatureMovement(creature) {
      if (creature.interval) {
        clearInterval(creature.interval);
      }
      
      console.log("üèÅ Starting movement for creature:", creature.data.type, "paused:", paused);
      
      // SIMPLE TEST - just move creatures right
      creature.interval = setInterval(() => {
        console.log("SIMPLE TEST - moving", creature.data.type, "paused:", paused);
        if (!paused) {
          const currentX = parseInt(creature.element.style.left) || 0;
          creature.element.style.left = (currentX + 1) + "px";
          console.log("MOVED", creature.data.type, "to", currentX + 1);
        }
      }, 100);
    }
    
    // HELPER FUNCTIONS - Much more readable!
    
    function applySpeciesBehavior(creature, boundaries, currentY) {
      const type = creature.data.type;
      
      if (type === "dolphin") {
        // Dolphins surface occasionally
        if (Math.random() < 0.008) {
          creature.surfacing = true;
          creature.surfaceTimer = 100;
        }
        
        if (creature.surfacing && creature.surfaceTimer > 0) {
          creature.vy -= 0.15; // Strong upward force
          creature.surfaceTimer--;
        } else {
          creature.surfacing = false;
          creature.vy -= 0.03; // Normal upward preference
        }
        
      } else if (type === "crab") {
        // Crabs stay at bottom with strong gravitational pull
        const bottomArea = boundaries.maxY - 50;
        const distanceFromBottom = Math.max(0, bottomArea - currentY);
        
        if (currentY < bottomArea) {
          // Strong pull toward bottom - increases with distance from bottom
          const pullStrength = 0.2 + (distanceFromBottom / 200) * 0.8; // 0.2 to 1.0 based on distance
          creature.vy += pullStrength;
        } else {
          creature.vy += 0.05; // Stay at bottom with gentle downward force
        }
        
        // Keep crabs moving horizontally but slower when falling
        if (currentY < bottomArea) {
          // Reduce horizontal movement when dropping
          creature.vx *= 0.7;
        }
        if (Math.abs(creature.vx) < 0.15) {
          creature.vx = creature.vx >= 0 ? 0.25 : -0.25;
        }
        
      } else if (type === "fish") {
        // Fish swim horizontally LEFT to RIGHT
        creature.vy *= 0.3; // Dampen vertical movement
        
        // Maintain rightward movement
        if (creature.vx < 0.6) {
          creature.vx = 0.8; // Force rightward movement
        }
        
        // Stay in middle water column
        const middleY = (boundaries.minY + boundaries.maxY) / 2;
        const distanceFromMiddle = currentY - middleY;
        creature.vy -= distanceFromMiddle * 0.002;
        
      } else if (type === "tuna") {
        // Tuna swim horizontally RIGHT to LEFT
        creature.vy *= 0.3; // Dampen vertical movement
        
        // Maintain leftward movement
        if (creature.vx > -0.6) {
          creature.vx = -0.8; // Force leftward movement
        }
        
        // Stay in middle water column
        const middleY = (boundaries.minY + boundaries.maxY) / 2;
        const distanceFromMiddle = currentY - middleY;
        creature.vy -= distanceFromMiddle * 0.002;
        
      } else if (type === "shark" || type === "whale") {
        // Sharks and whales swim LEFT to RIGHT (like fish but with more freedom)
        if (creature.vx < 0.4) {
          creature.vx = 0.6; // Maintain rightward movement but less strict than fish
        }
        
      } else if (type === "dolphin") {
        // Dolphins swim RIGHT to LEFT (like tuna but with surfacing behavior)
        if (creature.vx > -0.4) {
          creature.vx = -0.6; // Maintain leftward movement but less strict than tuna
        }
      }
    }
    
    function applyCollisionAvoidance(creature, currentX, currentY) {
      let avoidanceX = 0;
      let avoidanceY = 0;
      const avoidanceRadius = Math.max(creature.width, creature.height) + 15;
      
      for (const otherCreature of currentCreatures) {
        if (otherCreature === creature || otherCreature.element.classList.contains('dragging')) {
          continue;
        }
        
        const otherX = parseInt(otherCreature.element.style.left) || 0;
        const otherY = parseInt(otherCreature.element.style.top) || 0;
        
        const deltaX = currentX - otherX;
        const deltaY = currentY - otherY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance < avoidanceRadius && distance > 0) {
          const avoidanceStrength = (avoidanceRadius - distance) / avoidanceRadius;
          avoidanceX += (deltaX / distance) * avoidanceStrength * 0.5;
          avoidanceY += (deltaY / distance) * avoidanceStrength * 0.5;
        }
      }
      
      // Apply gentle avoidance
      creature.vx += avoidanceX * 0.03;
      creature.vy += avoidanceY * 0.03;
    }
    
    function addRandomMovement(creature) {
      // Small random direction changes
      if (Math.random() < 0.02) {
        const randomTurn = (Math.random() - 0.5) * 0.1;
        const cos = Math.cos(randomTurn);
        const sin = Math.sin(randomTurn);
        const newVx = creature.vx * cos - creature.vy * sin;
        const newVy = creature.vx * sin + creature.vy * cos;
        creature.vx = newVx;
        creature.vy = newVy;
      }
    }
    
    function enforceSpeedLimits(creature) {
      const maxSpeed = getMaxSpeed(creature.data.type);
      const minSpeed = getMinSpeed(creature.data.type, maxSpeed);
      
      let currentSpeed = Math.sqrt(creature.vx * creature.vx + creature.vy * creature.vy);
      
      // Prevent complete stopping
      if (currentSpeed < 0.05) {
        console.log(`‚ö†Ô∏è ${creature.data.type} too slow, boosting!`);
        creature.vx = (Math.random() - 0.5) * 0.6;
        creature.vy = (Math.random() - 0.5) * 0.6;
        currentSpeed = Math.sqrt(creature.vx * creature.vx + creature.vy * creature.vy);
      }
      
      // Enforce maximum speed
      if (currentSpeed > maxSpeed) {
        creature.vx = (creature.vx / currentSpeed) * maxSpeed;
        creature.vy = (creature.vy / currentSpeed) * maxSpeed;
        currentSpeed = maxSpeed;
      }
      
      // Enforce minimum speed
      if (currentSpeed < minSpeed) {
        creature.vx = (creature.vx / currentSpeed) * minSpeed;
        creature.vy = (creature.vy / currentSpeed) * minSpeed;
      }
    }
    
    function getMaxSpeed(type) {
      switch(type) {
        case "whale": return 1.5;
        case "shark": return 1.2;
        default: return 0.8;
      }
    }
    
    function getMinSpeed(type, maxSpeed) {
      switch(type) {
        case "tuna":
        case "fish": return maxSpeed * 0.6;
        case "crab": return maxSpeed * 0.3;
        default: return maxSpeed * 0.4;
      }
    }
    
    function handleBoundaryCollisions(creature, newX, newY, boundaries) {
      if (newX < boundaries.minX || newX > boundaries.maxX) {
        creature.vx *= -1;
      }
      if (newY < boundaries.minY || newY > boundaries.maxY) {
        creature.vy *= -1;
      }
    }
    
    function updateCreaturePosition(creature, newX, newY, boundaries) {
      const finalX = Math.max(boundaries.minX, Math.min(newX, boundaries.maxX));
      const finalY = Math.max(boundaries.minY, Math.min(newY, boundaries.maxY));
      
      creature.element.style.left = `${finalX}px`;
      creature.element.style.top = `${finalY}px`;
    }
    
    function updateCreatureDirection(creature) {
      const scaleX = creature.vx < 0 ? -1 : 1;
      if (creature.data.type === "whale") {
        creature.element.style.transform = `scaleX(${scaleX}) translateY(100px)`;
      } else {
        creature.element.style.transform = `scaleX(${scaleX})`;
      }
    }
    
    function updateSelectedCreatureCircle() {
      const circle = document.getElementById("selected-creature-circle");
      if (!circle || !selectedCreature) {
        if (circle) circle.style.display = "none";
        return;
      }
      
      // Get creature position
      const creatureElement = selectedCreature.element;
      const creatureX = parseInt(creatureElement.style.left) || 0;
      const creatureY = parseInt(creatureElement.style.top) || 0;
      const creatureWidth = selectedCreature.width || 50;
      const creatureHeight = selectedCreature.height || 50;
      
      // Calculate circle size (slightly larger than creature)
      const circleSize = Math.max(creatureWidth, creatureHeight) + 20;
      
      // Center the circle on the creature
      const circleX = creatureX + (creatureWidth / 2) - (circleSize / 2);
      const circleY = creatureY + (creatureHeight / 2) - (circleSize / 2);
      
      // Update circle position and size
      circle.style.left = `${circleX}px`;
      circle.style.top = `${circleY}px`;
      circle.style.width = `${circleSize}px`;
      circle.style.height = `${circleSize}px`;
      circle.style.display = "block";
    }
    
    function setSelectedCreature(creature) {
      selectedCreature = creature;
      updateSelectedCreatureCircle();
      console.log("üéØ Selected creature:", creature ? creature.data.type : "none");
    }

    function stopAllMovement() {
      currentCreatures.forEach(creature => {
        if (creature.interval) {
          clearInterval(creature.interval);
          creature.interval = null;
        }
      });
    }

    function updateCreatureBoundary() {
      const boundary = document.getElementById("creature-boundary");
      if (!boundary) {
        console.warn("‚ùå creature-boundary element not found!");
        return;
      }
      
      // Show ACTUAL usable space, don't try to avoid overlapping
      const minX = 20;
      const minY = 120;
      
      // Calculate the real available space (even if tiny)
      const realAvailableWidth = window.innerWidth - 370; // Space before info panel
      const realAvailableHeight = window.innerHeight - 220; // Space after title and margins
      
      // Show the actual boundary, even if it's small or overlaps
      let boundaryWidth, boundaryHeight;
      
      if (realAvailableWidth < 100) {
        // If very narrow, show what we have but make it at least visible
        boundaryWidth = Math.max(50, realAvailableWidth);
        console.log("üî¥ VERY NARROW WINDOW - showing minimal boundary:", boundaryWidth);
      } else {
        boundaryWidth = realAvailableWidth;
      }
      
      if (realAvailableHeight < 100) {
        // If very short, show what we have but make it at least visible  
        boundaryHeight = Math.max(50, realAvailableHeight);
        console.log("üî¥ VERY SHORT WINDOW - showing minimal boundary:", boundaryHeight);
      } else {
        boundaryHeight = realAvailableHeight;
      }
      
      const maxX = minX + boundaryWidth;
      const maxY = minY + boundaryHeight;
      
      boundary.style.left = minX + "px";
      boundary.style.top = minY + "px";
      boundary.style.width = boundaryWidth + "px";
      boundary.style.height = boundaryHeight + "px";
      boundary.style.display = "block";
      boundary.style.visibility = "visible";
      boundary.style.opacity = "0.8";
      
      console.log("üî≤ FORCED boundary display:", { 
        minX, minY, maxX, maxY, 
        width: boundaryWidth, 
        height: boundaryHeight,
        window: `${window.innerWidth}x${window.innerHeight}`,
        available: `${availableWidth}x${availableHeight}`
      });
    }

    document.getElementById("pause-btn").onclick = () => {
      console.log("PAUSE BUTTON CLICKED - paused was:", paused);
      
      paused = !paused;
      document.getElementById("pause-btn").innerText = paused ? "‚ñ∂" : "‚è∏";
      
      console.log("PAUSE BUTTON - now paused is:", paused);
      
      // Just stop/start movement - don't touch images for now
      if (paused) {
        console.log("PAUSE - stopping all movement");
        stopAllMovement();
      } else {
        console.log("UNPAUSE - starting all movement");
        currentCreatures.forEach(creature => {
          if (creature.data) {
            startCreatureMovement(creature);
          }
        });
      }
    };
    
    document.getElementById("block-prev").onclick = () => {
      searchBlockHeight = Math.max(1, searchBlockHeight - 1);
      document.getElementById("block-input").value = searchBlockHeight;
      fetchSearchBlock();
    };
    
    document.getElementById("block-next").onclick = () => {
      searchBlockHeight++;
      document.getElementById("block-input").value = searchBlockHeight;
      fetchSearchBlock();
    };
    
    document.getElementById("block-input").onchange = (e) => {
      searchBlockHeight = parseInt(e.target.value) || 1;
      fetchSearchBlock();
    };
    document.getElementById("day-night-toggle").onclick = () => {
      isNightMode = !isNightMode;
      document.getElementById("day-night-toggle").innerText = isNightMode ? "Night" : "Day";
      
      const radarLine = document.getElementById("radar-line");
      if (isNightMode) {
        radarLine.style.display = "block";
        radarPosition = 0;
      } else {
        radarLine.style.display = "none";
      }
    };

    // Get latest block height on startup and find one with creatures
    fetch("/latest").then(res => res.json()).then(data => {
      if (data.height) {
        searchBlockHeight = data.height;
        findBlockWithCreatures();
      } else {
        // Fallback to a known block if no latest data
        searchBlockHeight = 3744495;
        document.getElementById("block-input").value = searchBlockHeight;
        fetchSearchBlock();
      }
    }).catch(error => {
      console.error("Error fetching latest block:", error);
      // Fallback to a known block
      searchBlockHeight = 3744495;
      document.getElementById("block-input").value = searchBlockHeight;
      fetchSearchBlock();
    });

    // Function to find a block with creatures by searching backwards
    function findBlockWithCreatures() {
      console.log("Looking for block with creatures, trying:", searchBlockHeight);
      fetch(`/block/${searchBlockHeight}`).then(res => res.json()).then(data => {
        if (data.error || !data.creatures || data.creatures.length === 0) {
          // No creatures in this block, try the previous one
          searchBlockHeight = Math.max(1, searchBlockHeight - 1);
          if (searchBlockHeight >= 3744000) { // Don't search too far back
            findBlockWithCreatures();
          } else {
            // Give up and use fallback
            searchBlockHeight = 3744495; // Block we know has creatures
            document.getElementById("block-input").value = searchBlockHeight;
            fetchSearchBlock();
          }
        } else {
          // Found a block with creatures!
          console.log("Found block with creatures:", searchBlockHeight);
          document.getElementById("block-input").value = searchBlockHeight;
          fetchSearchBlock();
        }
      }).catch(error => {
        console.error("Error in findBlockWithCreatures:", error);
        searchBlockHeight = 3744495; // Block we know has creatures
        document.getElementById("block-input").value = searchBlockHeight;
        fetchSearchBlock();
      });
    }

    function clearAquarium() {
      currentCreatures.forEach(creature => {
        if (creature.interval) {
          clearInterval(creature.interval);
          creature.interval = null;
        }
      });
      currentCreatures = [];
      
      // Clear all active arrows
      activeArrows.forEach(arrowData => {
        if (arrowData.element.parentNode) {
          arrowData.element.parentNode.removeChild(arrowData.element);
        }
        if (arrowData.updateInterval) {
          clearInterval(arrowData.updateInterval);
        }
      });
      activeArrows = [];
      
      aquarium.innerHTML = `
        <div id="radar-line"></div>
        <div id="creature-boundary" style="position: absolute; left: 20px; top: 120px; width: 400px; height: 400px; border: 5px solid red; background-color: rgba(255,0,0,0.2); display: block; visibility: visible; opacity: 1; z-index: 15; pointer-events: none; box-sizing: border-box;"></div>
        <div id="selected-creature-circle"></div>
        <div style="position: absolute; left: 50px; top: 50px; width: 200px; height: 200px; border: 10px solid blue; background-color: yellow; z-index: 999;">TEST BOX - Should be visible</div>
      `;
    }

    function drawTransactionArrows(creatures) {
      console.log("=== ARROW DRAWING START ===");
      console.log("Total creatures:", creatures.length);
      
      // Count roles
      const senders = creatures.filter(c => c.role === 'sender');
      const receivers = creatures.filter(c => c.role === 'receiver');
      console.log("Senders:", senders.length, "Receivers:", receivers.length);
      
      if (senders.length > 0 && receivers.length > 0) {
        console.log("Drawing test arrow from first sender to first receiver");
        drawArrow(senders[0], receivers[0]);
      } else {
        console.log("No sender/receiver pairs found - no arrows to draw");
      }
      
      console.log("=== ARROW DRAWING END ===");
    }

    function updateArrowPosition(arrowData) {
      const fromElement = arrowData.fromElement;
      const toElement = arrowData.toElement;
      
      if (!fromElement || !toElement || !fromElement.parentNode || !toElement.parentNode) {
        return false; // Elements no longer exist
      }

      // Get center positions of creatures
      const fromRect = fromElement.getBoundingClientRect();
      const toRect = toElement.getBoundingClientRect();
      
      const fromX = fromRect.left + fromRect.width / 2;
      const fromY = fromRect.top + fromRect.height / 2;
      const toX = toRect.left + toRect.width / 2;
      const toY = toRect.top + toRect.height / 2;

      // Calculate arrow properties
      const deltaX = toX - fromX;
      const deltaY = toY - fromY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;

      // Update arrow element
      arrowData.element.style.left = fromX + 'px';
      arrowData.element.style.top = fromY + 'px';
      arrowData.element.style.width = distance + 'px';
      arrowData.element.style.transform = `rotate(${angle}deg)`;
      
      return true; // Successfully updated
    }

    function drawArrow(fromCreature, toCreature) {
      console.log("drawArrow called - from:", fromCreature.type, "to:", toCreature.type);
      
      // Find the actual creature elements by address
      const fromElement = currentCreatures.find(c => c.data.address === fromCreature.address)?.element;
      const toElement = currentCreatures.find(c => c.data.address === toCreature.address)?.element;
      
      console.log("Elements found - From:", !!fromElement, "To:", !!toElement);
      
      if (!fromElement || !toElement) {
        console.log("Missing elements, skipping arrow");
        return;
      }

      // Create arrow element
      const arrow = document.createElement('div');
      arrow.className = 'transaction-arrow';
      arrow.style.backgroundColor = 'red'; // Make it very visible for testing
      arrow.style.height = '4px';
      document.body.appendChild(arrow);

      console.log("Arrow element created and added to DOM");

      // Create arrow data object
      const arrowData = {
        element: arrow,
        fromElement: fromElement,
        toElement: toElement,
        updateInterval: null
      };

      // Initial position update
      updateArrowPosition(arrowData);

      // Add to active arrows
      activeArrows.push(arrowData);

      console.log("Arrow should now be visible");

      // Remove arrow after 10 seconds
      setTimeout(() => {
        if (arrow.parentNode) {
          arrow.parentNode.removeChild(arrow);
        }
        const index = activeArrows.indexOf(arrowData);
        if (index > -1) {
          activeArrows.splice(index, 1);
        }
      }, 10000);
    }

    function showInfo(c) {
      console.log("showInfo called with:", c);
      
      // Find the creature object that matches this data
      const creatureObj = currentCreatures.find(creature => 
        creature.data.address === c.address && creature.data.type === c.type
      );
      
      // Set as selected creature for green circle
      setSelectedCreature(creatureObj);
      
      const infoContent = document.getElementById("info-content");
      console.log("Info content element:", infoContent);
      
      // Define ADA ranges for each creature type
      const adaRanges = {
        shrimp: "< 100 ADA",
        crab: "100 - 999 ADA", 
        octopus: "1,000 - 2,999 ADA",
        fish: "3,000 - 9,999 ADA",
        tuna: "10,000 - 39,999 ADA",
        dolphin: "40,000 - 99,999 ADA",
        shark: "100,000 - 299,999 ADA",
        whale: "300,000+ ADA"
      };
      
      infoContent.innerHTML = `
        <div style="margin-bottom: 15px;">
          <b style="color: #2d4a3e; font-size: 13px;">Creature Type:</b><br>
          <span style="color: #8B4513; font-weight: bold; font-size: 14px; text-transform: capitalize;">${c.type}</span><br>
          <span style="color: #666; font-size: 11px; font-style: italic;">(${adaRanges[c.type] || 'Unknown range'})</span>
        </div>
        
        <div style="margin-bottom: 15px;">
          <b style="color: #2d4a3e; font-size: 13px;">Address:</b><br>
          <span style="font-size: 10px; word-break: break-all; line-height: 1.2;">${c.address}</span>
        </div>
        
        <div style="margin-bottom: 15px;">
          <b style="color: #2d4a3e; font-size: 13px;">ADA Balance:</b><br>
          <span style="color: #0066cc; font-weight: bold; font-size: 12px;">${c.ada} ADA</span>
        </div>
        
        <div style="margin-bottom: 15px;">
          <b style="color: #2d4a3e; font-size: 13px;">Role:</b><br>
          <span style="color: #666; font-size: 12px;">${c.role || 'N/A'}</span>
        </div>
        
        <div style="margin-bottom: 15px;">
          <b style="color: #2d4a3e; font-size: 13px;">Transaction ID:</b><br>
          <span style="font-size: 10px; word-break: break-all; line-height: 1.2;">${c.transaction_id || 'N/A'}</span>
        </div>
        
        <div style="margin-bottom: 10px;">
          <b style="color: #2d4a3e; font-size: 13px;">Amount Transferred:</b><br>
          <span style="color: #cc6600; font-weight: bold; font-size: 12px;">${c.amount_transferred ? c.amount_transferred.toFixed(2) + ' ADA' : 'N/A'}</span>
        </div>
      `;
    }

    function animate() {
      if (!paused && isNightMode) {
        radarPosition += 0.5; // Slower movement for night mode
        if (radarPosition > window.innerWidth) radarPosition = -10;
        document.getElementById("radar-line").style.left = radarPosition + "px";
      }
      requestAnimationFrame(animate);
    }


    function fetchSearchBlock() {
      console.log("*** FETCH SEARCH BLOCK CALLED ***", searchBlockHeight);
      fetch(`/block/${searchBlockHeight}`).then(res => res.json()).then(data => {
        console.log("*** BLOCK DATA RECEIVED ***", data);
        console.log("*** NUMBER OF CREATURES ***", data.creatures ? data.creatures.length : 0);
        
        if (data.error) {
          console.error("Block not found:", data.error);
          return;
        }

        clearAquarium();
        console.log("Aquarium cleared, processing creatures...");
        
        let blockLabel = document.querySelector('#search-block-label');
        if (!blockLabel) {
          blockLabel = document.createElement("div");
          blockLabel.id = "search-block-label";
          blockLabel.style.position = "absolute";
          blockLabel.style.top = "10px";
          blockLabel.style.left = "50%";
          blockLabel.style.transform = "translateX(-50%)";
          blockLabel.style.color = "white";
          blockLabel.style.fontSize = "22px";
          blockLabel.style.fontWeight = "bold";
          blockLabel.style.textShadow = "1px 1px 4px black";
          aquarium.appendChild(blockLabel);
        }
        blockLabel.innerText = `Search Block: ${data.height}`;

        if (data.creatures.length === 0) {
          // Show ghost for empty block in search mode
          const emptyImg = document.createElement("img");
          emptyImg.src = "/static/empty.gif";
          emptyImg.className = "empty-block-search";
          emptyImg.style.position = "absolute";
          emptyImg.style.left = "50%";
          emptyImg.style.top = "50%";
          emptyImg.style.transform = "translate(-50%, -50%)";
          emptyImg.style.height = "150px";
          emptyImg.style.width = "auto";
          emptyImg.style.filter = "brightness(0.7) contrast(1.2)";
          emptyImg.style.zIndex = "20";
          aquarium.appendChild(emptyImg);
          
          const spookyText = document.createElement("div");
          spookyText.className = "spooky-text-search";
          spookyText.innerText = "No Transactions in this Block";
          spookyText.style.position = "absolute";
          spookyText.style.left = "50%";
          spookyText.style.top = "65%";
          spookyText.style.transform = "translateX(-50%)";
          spookyText.style.color = "#ff6b6b";
          spookyText.style.fontSize = "16px";
          spookyText.style.fontWeight = "bold";
          spookyText.style.textShadow = "0 0 10px #ff6b6b, 0 0 20px #ff0000";
          spookyText.style.animation = "spookyGlow 2s ease-in-out infinite alternate";
          spookyText.style.textAlign = "center";
          spookyText.style.zIndex = "20";
          aquarium.appendChild(spookyText);
        } else {
          console.log("*** JAVASCRIPT IS RUNNING - Processing creatures:", data.creatures);
          
          // Calculate size based on ADA amount for more realistic scaling
          function calculateCreatureSize(ada, type) {
              let baseSize;
              let scaleFactor = 1;
              
              // Base sizes properly ordered: shrimp < crab < octopus < fish < tuna < dolphin < shark < whale
              if (type === "shrimp") {
                baseSize = 20; // Smallest (< 100 ADA)
                scaleFactor = Math.max(1, Math.min(ada / 50, 2)); // 1x to 2x
              } else if (type === "crab") {
                baseSize = 30; // (100-1000 ADA)
                scaleFactor = Math.max(1, Math.min((ada - 100) / 450 + 1, 2)); // 1x to 2x
              } else if (type === "octopus") {
                baseSize = 45; // (1000-3000 ADA)
                scaleFactor = Math.max(1, Math.min((ada - 1000) / 1000 + 1, 2)); // 1x to 2x
              } else if (type === "fish") {
                baseSize = 60; // (3000-10000 ADA) - bigger than octopus
                scaleFactor = Math.max(1, Math.min((ada - 3000) / 3500 + 1, 1.8)); // 1x to 1.8x
              } else if (type === "tuna") {
                baseSize = 80; // (10000-40000 ADA) - bigger than fish
                scaleFactor = Math.max(1, Math.min((ada - 10000) / 15000 + 1, 2)); // 1x to 2x
              } else if (type === "dolphin") {
                baseSize = 120; // (40000-100000 ADA) - bigger than tuna
                scaleFactor = Math.max(1, Math.min((ada - 40000) / 30000 + 1, 2.2)); // 1x to 2.2x
              } else if (type === "shark") {
                baseSize = 200; // (100000-300000 ADA) - much bigger than dolphin
                scaleFactor = Math.max(1, Math.min((ada - 100000) / 100000 + 1, 3)); // 1x to 3x
              } else { // whale
                baseSize = 350; // (300000+ ADA) - largest creatures
                scaleFactor = Math.max(1, Math.min((ada - 300000) / 200000 + 1, 3)); // 1x to 3x
              }
              
              return Math.floor(baseSize * scaleFactor);
            }
          
          // First, create all creatures
          for (const c of data.creatures) {
            console.log("*** CREATING CREATURE ***", c.type, "with ADA:", c.ada);
            const img = document.createElement("img");
            img.src = paused ? creatureImages[c.type].png : creatureImages[c.type].gif;
            img.className = "creature";
            console.log("IMG element created:", img);
            
            const creatureSize = calculateCreatureSize(c.ada, c.type);
            const creatureWidth = creatureSize;
            const creatureHeight = creatureSize;
            
            // Set size based on calculated creature size
            img.style.height = creatureSize + "px";
            img.style.width = "auto";
            
            // Only apply translateY for whales
            if (c.type === "whale") {
              img.style.transform = "translateY(100px)";
            }
            img.style.opacity = "0";
            aquarium.appendChild(img);
            console.log("=== CREATURE APPENDED TO DOM ===", c.type);

            // FORCE IMMEDIATE POSITIONING - don't wait for onload
            console.log("*** POSITIONING CREATURE IMMEDIATELY ***", c.type);
            
            console.log(`*** CREATURE ${c.type} DIMENSIONS: ${creatureWidth}x${creatureHeight}, WINDOW: ${window.innerWidth}x${window.innerHeight} ***`);
            
            // Account for whale's translateY transform
            const extraY = c.type === "whale" ? 100 : 0;
              
            // Ensure creatures stay fully visible in window with generous margins
            const minX = 20;
            const maxX = Math.max(minX + 50, window.innerWidth - 370 - creatureWidth); // Account for info panel
            const minY = 120; // Below the title
            const maxY = Math.max(minY + 50, window.innerHeight - 100 - creatureHeight - extraY); // Stay above bottom
            
            // Find a non-overlapping position for the creature
            let x, y;
            let attempts = 0;
            const maxAttempts = 50;
            
            do {
              x = Math.random() * (maxX - minX) + minX;
              y = Math.random() * (maxY - minY) + minY;
              
              // Clamp to ensure within bounds
              x = Math.max(minX, Math.min(x, maxX));
              y = Math.max(minY, Math.min(y, maxY));
              
              attempts++;
            } while (attempts < maxAttempts && isPositionOccupied(x, y, creatureWidth, creatureHeight));
            
            // Helper function to check if position overlaps with existing creatures
            function isPositionOccupied(newX, newY, width, height) {
              for (const existingCreature of currentCreatures) {
                const existingX = parseInt(existingCreature.element.style.left) || 0;
                const existingY = parseInt(existingCreature.element.style.top) || 0;
                const existingWidth = existingCreature.width || 50;
                const existingHeight = existingCreature.height || 50;
                
                // Check for overlap with padding
                const padding = 30;
                if (newX < existingX + existingWidth + padding && 
                    newX + width + padding > existingX &&
                    newY < existingY + existingHeight + padding && 
                    newY + height + padding > existingY) {
                  return true;
                }
              }
              return false;
            }
            
            console.log(`*** POSITIONING ${c.type} AT x:${x} (${minX}-${maxX}), y:${y} (${minY}-${maxY}) ***`);
            
            // Set initial positions and velocities based on creature type and direction
            let vx, vy;
            
            if (c.type === "fish" || c.type === "shark" || c.type === "whale") {
              // Fish, sharks, whales: start on LEFT side, swim RIGHT
              x = minX + Math.random() * 100; // Start in leftmost 100px
              vx = 0.6 + Math.random() * 0.4; // Always positive (rightward) 0.6-1.0 speed
              
              if (c.type === "fish") {
                vy = (Math.random() - 0.5) * 0.1; // Minimal vertical for fish
              } else if (c.type === "shark") {
                vy = (Math.random() - 0.5) * 0.4; // Normal vertical for sharks
              } else { // whale
                vy = (Math.random() - 0.5) * 0.6; // More vertical for whales
              }
              
            } else if (c.type === "tuna" || c.type === "dolphin") {
              // Tuna and dolphins: start on RIGHT side, swim LEFT
              x = Math.max(minX, maxX - 100) + Math.random() * 100; // Start in rightmost 100px
              vx = -(0.6 + Math.random() * 0.4); // Always negative (leftward) -0.6 to -1.0 speed
              
              if (c.type === "tuna") {
                vy = (Math.random() - 0.5) * 0.1; // Minimal vertical for tuna
              } else { // dolphin
                vy = (Math.random() - 0.5) * 0.4; // Normal vertical for dolphins
              }
              
            } else if (c.type === "crab") {
              // Crabs start near bottom with slow movement (unchanged)
              vx = (Math.random() - 0.5) * 0.3;
              vy = Math.abs(Math.random() - 0.5) * 0.2; // Slight downward bias
              y = Math.max(y, maxY - 80); // Start closer to bottom
            } else {
              // Other creatures (octopus, shrimp) use original logic
              vx = (Math.random() - 0.5) * 0.4;
              vy = (Math.random() - 0.5) * 0.3;
            }

            img.style.left = `${x}px`;
            img.style.top = `${y}px`;
            
            // Create the creature object with behavior properties
            const creatureObj = { 
              element: img, 
              interval: null, 
              data: c, 
              x: x, 
              y: y, 
              vx: vx, 
              vy: vy, 
              width: creatureWidth, 
              height: creatureHeight,
              surfacing: false, // For dolphins
              surfaceTimer: 0   // For dolphins
            };
            currentCreatures.push(creatureObj);
            
            // Start movement if not paused
            console.log("üöÄ About to start movement - paused:", paused);
            if (!paused) {
              console.log("‚úÖ Starting movement for:", c.type);
              startCreatureMovement(creatureObj);
            } else {
              console.log("‚ùå NOT starting movement - paused is true");
            }
            
            // Show the creature after positioning
            setTimeout(() => {
              img.style.opacity = "1";
              console.log("=== CREATURE NOW VISIBLE ===", c.type);
            }, 100);

            // SIMPLE TEST - just log and do NOTHING ELSE
            img.onclick = (e) => {
              console.log("CLICK TEST - before any action, position:", img.style.left, img.style.top);
              e.stopPropagation();
              showInfo(c);
              console.log("CLICK TEST - after showInfo, position:", img.style.left, img.style.top);
            };
            
            img.onmousedown = (e) => {
              e.preventDefault();
              e.stopPropagation();
              
              const currentX = parseInt(img.style.left) || 0;
              const currentY = parseInt(img.style.top) || 0;
              
              draggedCreature = { element: img };
              dragOffset.x = e.clientX - currentX;
              dragOffset.y = e.clientY - currentY;
              img.classList.add('dragging');
              
              // Switch to click image
              img.dataset.originalSrc = img.src;
              img.src = `/static/${c.type}_click.png`;
            };

          }
          
          // After all creatures are created and positioned, draw arrows
          setTimeout(() => drawTransactionArrows(data.creatures), 200);
        }
      }).catch(error => {
        console.error("Error fetching block:", error);
      });
    }

    // Initialize when DOM is ready
    document.addEventListener("DOMContentLoaded", function() {
      document.getElementById("radar-line").style.display = "none";
      document.getElementById("search-controls").style.display = "block";
      
      console.log("üöÄ DOM ready - boundary should be visible from inline styles");
    });
    
    // DISABLED ALL BOUNDARY MANIPULATION - using inline styles only
    function updateCreatureBoundary() {
      // DO NOTHING - boundary is set with inline HTML styles
      console.log("üî¥ updateCreatureBoundary disabled - using inline styles");
    }

    document.onmousemove = (e) => {
      if (draggedCreature) {
        const newX = e.clientX - dragOffset.x;
        const newY = e.clientY - dragOffset.y;
        
        const creature = currentCreatures.find(c => c.element === draggedCreature.element);
        if (creature) {
          const creatureWidth = creature.width || draggedCreature.element.offsetWidth;
          const creatureHeight = creature.height || draggedCreature.element.offsetHeight;
          
          const boundedX = Math.max(0, Math.min(newX, window.innerWidth - creatureWidth));
          const boundedY = Math.max(100, Math.min(newY, window.innerHeight - creatureHeight));
          
          draggedCreature.element.style.left = `${boundedX}px`;
          draggedCreature.element.style.top = `${boundedY}px`;
          
          creature.x = boundedX;
          creature.y = boundedY;
        }
      }
    };

    document.onmouseup = () => {
      if (draggedCreature) {
        draggedCreature.element.classList.remove('dragging');
        
        // Find the creature object to restore its behavior
        const creature = currentCreatures.find(c => c.element === draggedCreature.element);
        if (creature) {
          // Restore species-specific velocities after dragging
          if (creature.data.type === "crab") {
            // Crabs should drop quickly to the bottom when released
            creature.vx = (Math.random() - 0.5) * 0.2; // Minimal horizontal movement
            creature.vy = 1.5; // Very strong downward movement to drop quickly
          } else if (creature.data.type === "fish" || creature.data.type === "shark" || creature.data.type === "whale") {
            // Fish, sharks, whales resume rightward swimming
            creature.vx = 0.8; // Always rightward
            creature.vy = (Math.random() - 0.5) * 0.2;
          } else if (creature.data.type === "tuna" || creature.data.type === "dolphin") {
            // Tuna and dolphins resume leftward swimming
            creature.vx = -0.8; // Always leftward
            creature.vy = (Math.random() - 0.5) * 0.2;
          } else {
            // Other creatures resume normal movement
            creature.vx = (Math.random() - 0.5) * 0.5;
            creature.vy = (Math.random() - 0.5) * 0.4;
          }
        }
        
        // Restore original image if it was changed
        if (draggedCreature.element.dataset.originalSrc) {
          draggedCreature.element.src = draggedCreature.element.dataset.originalSrc;
          delete draggedCreature.element.dataset.originalSrc;
        }
        
        draggedCreature = null;
      }
    };
    
    // Background click to make creatures swim towards click point
    document.onclick = (e) => {
      if (e.target.classList.contains('creature')) return; // Don't trigger on creature clicks
      if (e.target.id === 'block-input' || e.target.id === 'block-prev' || e.target.id === 'block-next') return; // Don't trigger on search controls
      
      const targetX = e.clientX;
      const targetY = e.clientY;
      
      // Create ripple effect
      const ripple = document.createElement('div');
      ripple.className = 'ripple-effect';
      ripple.style.left = (targetX - 10) + 'px';
      ripple.style.top = (targetY - 10) + 'px';
      document.body.appendChild(ripple);
      
      // Remove ripple after animation completes
      setTimeout(() => {
        if (ripple.parentNode) {
          ripple.parentNode.removeChild(ripple);
        }
      }, 1000);
      
      currentCreatures.forEach(creature => {
        if (!creature.element || !creature.data) return; // Skip empty block elements
        
        // Get current position from DOM
        const currentX = parseInt(creature.element.style.left) || 0;
        const currentY = parseInt(creature.element.style.top) || 0;
        
        // Calculate direction towards target
        const deltaX = targetX - currentX;
        const deltaY = targetY - currentY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance > 0) {
          // Normalize and set appropriate speed
          const speed = creature.data.type === "whale" ? 1.5 : creature.data.type === "shark" ? 1.2 : 0.8;
          creature.vx = (deltaX / distance) * speed;
          creature.vy = (deltaY / distance) * speed;
        }
      });
    };

    animate();
  </script>
</body>
</html>
